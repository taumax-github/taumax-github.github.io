<!DOCTYPE html>

<html lang="ja">
  <head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <meta charset="UTF-8">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="expires" content="0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="Content-Script-Type" content="text/javascript" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="ITエンジニアがこれまで学んだことを整理するサイト" />
    <meta name="keywords" content="IT,エンジニア">

    <link rel="stylesheet" href="../../../css/style.css">
    <link rel="stylesheet" href="../../../css/print.css" media="print">
    <script src="../../../js/openclose.js"></script>

    <title>とあるＩＴエンジニアの知識整理</title>
    
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <style>
      .menu1 a {background-position: -10px -10px;}
      .menu2 a {background-position: -10px -130px;}
      .menu3 a {background-position: -10px -250px;}
      .menu4 a {background-position: -10px -370px;}
      .menu5 a {background-position: -10px -490px;}
    </style>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-156501005-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-156501005-1');
    </script>
  </head>

  <!--PC用（801px以上端末）で表示させるブロック-->
  <header class="pc">
    <h1 class="logo">
      <a href="https://nailmaru.github.io/"><img src="../../../images/logo.png" alt="TOP"></a>
    </h1>

    <!--PC用（801px以上端末）メニュー-->
    <nav id="menubar">
      <ul>
        <li class="menuimg menu1"><a href="https://nailmaru.github.io/"><span>Home</span></a></li>
      </ul>
    </nav>
    <ul class="icon">
      <li><a href="https://twitter.com/marukugi" target="_blank"><img src="../../../images/icon_twitter.png" alt="Twitter"></a></li>
      <li><a href="https://qiita.com/taumax" target="_blank"><img src="../../../images/icon_qiita.png" alt="Qiita"></a></li>
    </ul>
  </header><!--/.pc-->

  <!--小さな端末用（800px以下端末）で表示させるブロック-->
  <header class="sh">
    <h1 class="logo">
      <a href="https://nailmaru.github.io/"><img src="../../../images/logo.png" alt="SAMPLE SITE"></a>
    </h1>

    <!--小さな端末用（800px以下端末）メニュー-->
    <div id="menubar-s">
      <nav>
        <ul><li class="menuimg menu1"><a href="https://nailmaru.github.io/"><span>Home</span></a></li></ul>
      </nav>
      <ul class="icon">
        <li><a href="https://twitter.com/marukugi" target="_blank"><img src="../../../images/icon_twitter.png" alt="Twitter"></a></li>
        <li><a href="https://qiita.com/taumax" target="_blank"><img src="../../../images/icon_qiita.png" alt="Qiita"></a></li>
      </ul>
    </div><!--/#menubar-s-->
  </header><!--/.sh-->

  <body class="defaultbody">
    <div id="container">
    <div id="contents">
    <div id="main">
      <span id="pagetop"></span>
      <section class="box">
        <h2 class="title">とあるＩＴエンジニアの知識整理</h2>

        <h2 id="bloaters">Bloaters</h2>
          <p><a href="https://sourcemaking.com/refactoring/smells/bloaters">Bloaters（膨れ上がったコード）</a>：
作業が困難になってしまうほど巨大になりすぎてしまったコード、メソッド、およびクラスのこと。
通常、これらのCode Smellはすぐには現れず、プログラムに改修を積み重ねること（そして特に誰もそれらを根絶する努力をしないとき）で現れます。</p>
<h3 id="longmethod">Long Method</h3>
<p><a href="https://sourcemaking.com/refactoring/smells/long-method">Long Method（長すぎるメソッド）</a></p>
<p><strong><em>兆候と症状</em></strong>
メソッドの行数が多すぎる状態。一般に、1メソッドの行数が10行を超える場合、短くすることができないかを考える必要があります。</p>
<p><strong><em>問題の理由</em></strong>
メソッドには常に何かしらの処理が追加され続けますが、処理が削除されるということはめったにありません。コードは読むよりも書く方が簡単なので、この Code Smell は、メソッドが異常なほど大きくなるまで気付かれないままです。
精神的には、既存のメソッドに処理を追加するよりも新しいメソッドを作成する方が難しく感じられます。たった2行の処理を追加するためだけに新しいメソッドを1つ追加するのが難しい場合などです。このようにして既存のメソッドに追加されたコードがスパゲッティコードの始まりになります。</p>
<p><strong><em>対処</em></strong>
経験則として、メソッド内の何かにコメントする必要があると感じた場合、このコードをメソッド内から抽出して新しいメソッドを作成する必要があります。説明が必要な場合は、1行であっても別の方法に分割することができます。また、メソッドにわかりやすい名前が付けられている場合、コードを調べてその機能を確認する必要はありません。</p>
<ul>
  <li><p>メソッド本体の長さを短くするには、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#extract-method">Extract Method</a>」を使用します。</p></li>
  <li><p>ローカル変数とパラメーターがメソッドの抽出に干渉する場合は、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#replace-temp-with-query">Replace Temp with Query</a>」、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#introduce-parameter-object">Introduce Parameter Object</a>」、または「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#preserve-whole-object">Preserve Whole Object</a>」を使用します。</p></li>
  <li><p>上記のレシピがどれも役に立たない場合は、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#replace-method-with-method-object">Replace Method with Method Object</a>」を適用してメソッド全体を別のオブジェクトに移動してみてください。</p></l  i>
  <li><p>条件演算子（3項演算子）とループは、コードを別のメソッドに移動できる良い手がかりです。3項演算子の場合は、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#decompose-conditional">Decompose Conditional</a>」を使用します。ループが邪魔な場合は、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#extract-method">Extract Method</a>」を試してください。</p></li>
</ul>
<p><strong><em>効果</em></strong></p>
<ul>
  <li>オブジェクト指向プログラミングにおいて、メソッドが短い方がそのクラスの寿命は長くなります。メソッドが長くなるとそれを理解することが難しくなり、メンテナンスも困難になります。</li>
  <li>さらに、メソッドが長くなるとコードの重複を発見するのが難しくなります。</li>
</ul>
<p><strong><em>Performance</em></strong>
リファクタリングによってメソッドが増えることがあります。
多くの人は、メソッドが増えると処理性能に影響があると主張します。しかしほとんどの場合、処理性能に与える影響はごくわずかです。
さらに、明確で理解可能なコードが得られたので、コードが再構築され、必要に応じて実際のパフォーマンスを向上させるための真に効果的な方法を見つける可能性が高くなります。</p>
<h3 id="largeclass">Large Class</h3>
<p><a href="https://sourcemaking.com/refactoring/smells/large-class">Large Class（巨大なクラス）</a>：</p>
<p><strong><em>兆候と症状</em></strong>
多くのフィールド、メソッド、コード行数を持つクラス。</p>
<p><strong><em>問題の理由</em></strong>
通常、クラスは最初は小さいものから始まります。しかし、時間の経過と共にプログラムは成長し、肥大化していきます。
Code Smell の一つである Long Method の場合もそうですが、プログラマーは通常、その機能の新しいクラスを作成するよりも、既存のクラスに新しい機能を配置する方が負担が少ないと考えます。</p>
<p><strong><em>対処</em></strong>
クラスがあまりにも多くの機能を持ってしまっている場合、それを分割することを考えてください。</p>
<ul>
  <li>「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#extract-class">Extract Class</a>」は、大きなクラスの動作の一部を別のコンポーネントに分割できる場合に役立ちます。</li>
  <li>「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#extract-subclass">Extract Subclass</a>」は、大きなクラスの一部を異なる方法で実装できる場合や、まれに使用される場合に役立ちます。</li>
  <li>「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#extract-interface">Extract Interface</a>」は、利用可能な操作と動作のリストを保持する必要がある場合に役立ちます。</li>
  <li>大きなクラスがグラフィカルインターフェイスを担当している場合、そのデータと動作の一部を別のドメインオブジェクトに移動しようとする場合があります。その際、一部のデータのコピーを2か所に保存し、データの一貫性を保つ必要がある場合があります。「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#duplicate-observed-data">Duplicate Observed Data</a>」はこれを行う方法を提供します。</li>
</ul>
<p><strong><em>効果</em></strong></p>
<ul>
  <li>これらのクラスのリファクタリングにより、開発者はクラスの多数の属性を覚える必要がなくなります。</li>
  <li>多くの場合、大きなクラスをパーツに分割すると、コードと機能の重複を避けられます。</li>
</ul>
<h3 id="primitiveobsession">Primitive Obsession</h3>
<p><a href="https://sourcemaking.com/refactoring/smells/primitive-obsession">Primitive Obsession（基本データ型への執着）</a>：</p>
<p><strong><em>兆候と症状</em></strong></p>
<ul>
  <li>単純なタスク（通貨、範囲、電話番号用の特別な文字列など）に小さなクラスを作る代わりにプリミティブ型（intやlongなど）を使用する。</li>
  <li>コーディング情報への定数の使用（管理者権限を持つユーザーを参照するための定数USER<em>ADMIN</em>ROLE = 1など）。</li>
  <li>データ配列で使用するフィールド名としての文字列定数の使用。</li>
</ul>
<p><strong><em>問題の理由</em></strong>
他のほとんどのCode Smell同様、Primitive Obsessionは弱さの瞬間に生まれます。
例えば、クラス内にプリミティブフィールドを作成するような行為です。プリミティブフィールドの作成は、新しいクラスを作成するよりもはるかに簡単です。フィールドが必要になるたびにプリミティブフィールドが追加されます。追加を繰り返した結果、クラスは巨大で扱いにくくなっていきます。</p>
<p>プリミティブは、型に”似せる”ためにもよく使用されます。個別のデータ型の代わりに、いくつかのエンティティの許容値のリストを形成する一連の数値または文字列を定数で宣言します。これらの定数には、わかりやすい名前を付けることができます。これは広く普及してしまっているやり方です。</p>
<p>プリミティブ型を使用した別の質の悪い例は、フィールドシミュレーションです。多様なデータの大規模な配列をクラスに含め、このデータを取得するための配列インデックスとして、クラスで指定した文字列定数が使用されます。</p>
<p><strong><em>対処</em></strong>
さまざまなプリミティブフィールドがある場合、それらのいくつかを論理的に独自のクラスにグループ化できる場合があります。さらに、このデータに関連付けられた振る舞いもそのクラスに移動するとより良いです。このタスクでは、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#replace-data-value-with-object">Replace Data Value with Object</a>」を試してください。</p>
<ul>
  <li><p>プリミティブフィールドの値がメソッド引数で使用されている場合は、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#introduce-parameter-object">Introduce Parameter Object</a>」または「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#preserve-whole-object">Preserve Whole Object</a>」を試してみましょう。</p></li>
  <li><p>複雑なデータが変数でコーディングされている場合は、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#replace-type-code-with-class">Replace Type Code with Class</a>」, 「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#replace-type-code-with-subclasses">Replace Type Code with Subclasses</a>」または「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#replace-type-code-with-statestrategy">Replace Type Code with State/Strategy</a>」を試してみましょう。</p></li>
  <li><p>1つの配列に複数の型が含まれている場合は「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#replace-array-with-object">Replace Array with Object</a>」を使用します。</p></li>
</ul>
<p><strong><em>効果</em></strong></p>
<ul>
  <li>プリミティブの代わりにオブジェクトを使用することで、コードがより柔軟になります。</li>
  <li>コードが理解しやすくなり、プログラムの構成が改善されます。特定のデータに対する操作が分散せず、同じ場所にあります。定数の意味と、それらが配列内にある意図について推測する必要がなくなります。</li>
  <li>重複コードの発見が容易になります。</li>
</ul>
<h3 id="longparameterlist">Long Parameter List</h3>
<p><a href="https://sourcemaking.com/refactoring/smells/long-parameter-list">Long Parameter List（長すぎるパラメータリスト）</a></p>
<p><strong><em>兆候と症状</em></strong>
メソッドの3つまたは4つ以上のパラメーター。</p>
<p><strong><em>問題の理由</em></strong>
Long Parameter Listは、いくつかの種類のアルゴリズムが単一のメソッドに統合された後に発生する場合があります。実行されるアルゴリズムとその方法を制御するために、Long Parameter Listが作成されている場合があります。</p>
<p>Long parameter listsは、クラスを互いに独立させる努力の副産物でもあります。たとえば、メソッドに必要な特定のオブジェクトを生成するコードをメソッド内部から呼び出し元に移動した場合、生成されたオブジェクトは引数としてメソッドに渡されます。これにより、元のクラスはオブジェクト間の関係を認識しなくなり、依存関係が減少します。ただし、このようなオブジェクトがいくつも作成された場合、各オブジェクトには独自のパラメーターが必要になります。つまり、パラメーターリストが長くなります。
そのようなリストを理解することは難しく、それらが長くなるにつれて矛盾し、使いにくくなります。Long parameter listsの代わりに、メソッドは自オブジェクトのデータを使用できます。現在のオブジェクトに必要なデータがすべて含まれていない場合は、必要なデータを取得する別オブジェクトをメソッドパラメーターとして渡すことができます。</p>
<p><strong><em>対処</em></strong>
パラメーターに渡される値を確認します。引数の一部が別のオブジェクトのメソッド呼び出しの結果である場合は、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#replace-parameter-with-method-call">Replace Parameter with Method Call</a>」を使用します。このリファクタリングによって作成されたオブジェクトは、対象のクラスのフィールドに配置するか、メソッドパラメーターとして渡すことができます。</p>
<ul>
  <li><p>別のオブジェクトから受け取ったデータのグループをパラメーターとして渡す代わりに、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#preserve-whole-object">Preserve Whole Object</a>」を使用して、オブジェクト自体をメソッドに渡します。</p></li>
  <li><p>関係のないデータ要素が複数ある場合、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#introduce-parameter-object">Introduce Parameter Object</a>」を介してそれらを単一のパラメータオブジェクトにマージできる場合があります。</p></li>
</ul>
<p><strong><em>効果</em></strong></p>
<ul>
  <li>コードが読みやすく、短くなる。</li>
  <li>リファクタリングすることでコードの重複に気づくきっかけになる。</li>
</ul>
<h3 id="dataclumps">Data Clumps</h3>
<p><a href="https://sourcemaking.com/refactoring/smells/data-clumps">Data Clumps（データの塊）</a></p>
<p><strong><em>兆候と症状</em></strong>
同一の変数グループ（データベースに接続するためのパラメーターなど）がコードの異なる部分に散らばっている場合があります。このData Clumpsは、独自のクラスに変換する必要があります。</p>
<p><strong><em>問題の理由</em></strong>
多くの場合、これらのデータグループは、不十分なプログラム構造またはコピペプログラミングが原因です。
一部のデータがData Clumpsであるかどうかを確認したい場合は、データ値の1つを削除し、他の値が依然として意味をなすかどうかを確認します。意味をなさなくなった場合は、その変数グループをオブジェクトにまとめる必要があることを示す良い兆候です。</p>
<p><strong><em>対処</em></strong>
繰り返しデータがクラスのフィールドで構成される場合、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#extract-class">Extract Class</a>」を使用してフィールドを独自のクラスに移動します。
メソッドのパラメーターで同じデータの塊が渡される場合は、「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#introduce-parameter-object">Introduce Parameter Object</a>」を使用してそれらをクラスとして設定します。
一部のデータが他のメソッドに渡される場合、個々のフィールドだけではなく、データオブジェクト全体をメソッドに渡すことを検討してください。「<a href="https://qiita.com/taumax/items/f192b16676f78fa04849#preserve-whole-object">Preserve Whole Object</a>」がこれに役立ちます。
これらのフィールドで使用されるコードを見てください。このコードをデータクラスに移動することをお勧めします。</p>
<p><strong><em>効果</em></strong></p>
<ul>
  <li>ソースコードが理解しやすくなります。また、コードの構成が改善されます。特定のデータに対する操作は、コード全体で無計画に行われるのではなく、単一の場所に収集されるようになりました。</li>
  <li>コードのサイズを小さくすることができます。</li>
</ul>

      </section><!-- section class="box" -->
    </div><!--/#main-->
    </div><!--/#contents-->
    </div><!--/#container-->
  </body>

  <!--ページの上部に戻る「↑」ボタン-->
  <p class="nav-fix-pos-pagetop"><a href="#pagetop">↑</a></p>

  <!--メニュー開閉ボタン-->
  <div id="menubar_hdr" class="close"></div>
    <!--メニューの開閉処理条件設定　800px以下-->
    <script>
      if (OCwindowWidth() <= 800) {
        open_close("menubar_hdr", "menubar-s");
      }
    </script>

    <footer>
      <small><a href="https://nailmaru.github.io/">とあるＩＴエンジニアの知識整理</a> All Rights Reserved.</small>
      <span class="pr"><a href="https://template-party.com/" target="_blank">《Web Design:Template-Party》</a></span>
    </footer>
</html>
