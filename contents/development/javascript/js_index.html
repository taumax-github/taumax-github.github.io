<!DOCTYPE html>

<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="expires" content="0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="Content-Script-Type" content="text/javascript" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="ITエンジニアがこれまで学んだことを整理するサイト" />
    <meta name="keywords" content="IT,エンジニア">

    <link rel="stylesheet" href="../../../css/style.css">
    <link rel="stylesheet" href="../../../css/print.css" media="print">
    <script src="../../../js/openclose.js"></script>

    <title>とあるＩＴエンジニアの知識整理</title>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-141266564-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-141266564-1');
    </script>
    <script data-ad-client="ca-pub-5924490903263360" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </head>

  <!--PC用（801px以上端末）で表示させるブロック-->
  <header class="pc">
    <h1 class="logo">
      <a href="https://taumax-github.github.io/"><img src="../../../images/icon_twitter_card.png" alt="TOP"></a>
    </h1>

    <!--PC用（801px以上端末）メニュー-->
    <nav id="menubar">
      <ul class="none">
        <li class="menuimg menu1"><a href="https://taumax-github.github.io/"><span>Home</span></a></li>
      </ul>
    </nav>
    <ul class="icon">
      <li><a href="https://twitter.com/taumax_" target="_blank"><img src="../../../images/icon_twitter.png" alt="Twitter"></a></li>
      <li><a href="https://qiita.com/taumax" target="_blank"><img src="../../../images/icon_qiita.png" alt="Qiita"></a></li>
    </ul>
  </header><!--/.pc-->

  <!--小さな端末用（800px以下端末）で表示させるブロック-->
  <header class="sh">
    <!--小さな端末用（800px以下端末）メニュー-->
    <div id="menubar-s">
      <h1 class="logo">
        <a href="https://taumax-github.github.io/"><img src="../../../images/icon_twitter_card.png" alt="SAMPLE SITE"></a>
      </h1>
      <nav>
        <ul class="none">
          <li class="menuimg menu1"><a href="https://taumax-github.github.io/"><span>Home</span></a></li>
        </ul>
      </nav>
      <ul class="icon">
        <li><a href="https://twitter.com/taumax_" target="_blank"><img src="../../../images/icon_twitter.png" alt="Twitter"></a></li>
        <li><a href="https://qiita.com/taumax" target="_blank"><img src="../../../images/icon_qiita.png" alt="Qiita"></a></li>
      </ul>
    </div><!--/#menubar-s-->
  </header><!--/.sh-->

  <body class="defaultbody">
    <div id="container">
    <div id="contents">
    <div id="main">
      <span id="pagetop"></span>
      <section class="box">

        <!-- tweetボタン -->
        <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
        <h2 class="title">JavaScript関連技術</h2>

        <ul class="breadcrumb">
          <li class="breadcrumbli"><a href="../../../index.html">ホーム</a></li>
          <li class="breadcrumbli"> > JavaScript</li>
        </ul>

        <br/>
        <h3 class="title">はじめに</h3>
        <p>
          自分が入社した当時、プログラミング言語はJavaが主流で、殆どJava一強という時代でした。<br/>
          JavaScriptも人気のある言語でしたが、UI周りをちょっと便利にするという使い方（ポップアップを出したり未入力項目を赤字にしたり）が多く、サーバーサイドで業務処理を実装する時にはJavaがよく使われるという時代でした。<br/>
          当時は人気の言語1位常連だったJavaが、いつの間にか1位から転落。最近では「Javaは時代遅れ」等という声が聞こえてくることもあります（個人的には時代遅れは言い過ぎな気もしていますが）。最近（2024年3月現在）は、PythonやJavaScript等が人気の言語上位にランクインしているのをよく見かけるようになりました。<br/>
          以下は1965-2022年の人気言語の変遷の動画と、一部画像を抜粋したものです。<br/>
          <img src="./img/popularity_2006q4.jpg" width="400"/>
          <img src="./img/popularity_2022q4.jpg" width="400"/><br/>
          ※画像は以下動画から抜粋。<br/>
        </p>

        <br/>
        <div class="youtube">
          <iframe width="560" height="315" src="https://www.youtube.com/embed/qQXXI5QFUfw?si=JQ6BPn4AWPhRNB5G" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>

        <br/>
        <p>
          Pythonは機械学習の分野で豊富なライブラリを提供しているから、AIの分野で現在人気なのはわかる。<br/>
          JavaScriptはなんで人気なのか？自分が入社した時代から何が変わったのか？そもそもJavaScriptってクライアントサイドで動いているものなのでは？？<br/>
          ぐらいの認識だったので調べてみました。<br/>
        </p>

        <br/>
        <h3 class="title">Webの歴史</h3>
        <h4 class="title">Webの誕生とWebベースシステムの発展</h4>
        <p>
          Webは1991年にインターネット上に登場しました。誕生したばかりのWebは文章閲覧のためのものでしかなかったのですが、1990年代半ば以降、CSSやJavaScriptがWebブラウザに搭載されるようになりました。<br/>
          同時期、CGIをはじめWeb向けのサーバーサイドプログラム技術が登場しました。これにより、データベースによるデータ管理、サーバーのHTML描画、クライアント（Webブラウザ）によるユーザーインタフェースという古典的なWebシステムが生まれます。Webブラウザをプレゼンテーション層としたWebベースによる三層アーキテクチャ型システムの登場です。<br/>
          サーバーサイドはCGIから進化を続けます。Ruby on RailsのようなMVCベースのWebアプリケーションフレームワークも登場しました。Webシステムが洗練されていくにつれ、ECサイトやブログなどのようなWebサービスが提供されるまでに至ります。<br/>
          これらの発展は重要ですが、Webフロントエンドにはあまり影響がありません。この当時、フロントエンドに求められていたのはCSSによる装飾、JavaScriptによるアラートや入力受付程度のものです。現代のようなフロントエンドを専門で開発するエンジニア職種はほぼ皆無でした。サーバーサイドを担うバックエンドエンジニアがほぼ全て開発していることが多かったでしょう。<br/>
        </p>

        <br/>
        <h4 class="title">Ajaxの登場</h4>
        <p>
          フロントエンドは見た目の補助をするだけというのが一時は常識でした。しかし、2005年にGoogle社が地図サービスGoogleMapsをリリースしてこの常識は覆されます。<br/>
          GoogleMapsは当時としては革新的な、ページ遷移することなくWebブラウザ側で地図を拡大・縮小する機能を提供しました。Ajaxと呼ばれる、JavaScriptによってサーバーと非同期も通信する技術によって実現しています。同一ページ内でコンテンツが高速かつインタラクティブに動く、軽快なUXがAjaxによって提供されるようになります。<br/>
          Ajaxの衝撃以降、クライアントサイドではAjaxとそれを活用したDOMの高度な操作が求められるようになります。それに応えるjQueryなどのライブラリが人気を集めました。<br/>
          サーバーサイドにおいては、Webサーバーは従来のHTMLレンダリングだけでなく、RESTfulをベースとしたWeb APIも提供するようになります。<br/>
          AjaxとWeb APIにより、よりリッチなWeb業務システムやWebサービスを構築するのが一般的になりました。Webブラウザ側でもJavaScriptを駆使して本格的なプログラムが書かれることになります。<br/>
          この頃から開発のサーバーサイド、クライアントサイドの分業化が見られるようになります。クライアントサイドはWebフロントエンドとして確立していくようになりました。<br/>
        </p>

        <br/>
        <h3 class="title">HTML5, Node.js, ES2015, React以降の世界</h3>
        <p>
          00年代末から10年代にかけてWebはさらに複雑化、高度化していくことになります。HTML5, Node.js, ES2015, Reactの4つの視点からその過程を見ていきましょう。<br/>
        </p>

        <br/>
        <h4 class="title">HTML5の登場とWebアプリケーションプラットフォーム化</h4>
        <p>
          HTML5は2014年に勧告された仕様です。HTMLの文書仕様だけでなく、Web全体の仕様をアップデートする大きなムーブメントとなっていきました。HTML5では、Webをアプリケーションプラットフォームとしても機能させられるよう、HTML/CSSやDOM APIには強力な仕様変更が入れられました。<br/>
          著者が最も重要だと考えているのがHistory APIです。History APIによって、ページの遷移をWebブラウザではなくJavaScriptでハンドリングできるようになりました。これによってコンテンツを画面遷移なしに、URLや履歴は管理しつつ切り替えるシングルページアプリケーションの構築が可能になりました。ネイティブアプリケーションのようなUXをエンドユーザーに提供します。<br/>
          HTML5の登場とそれに伴うライブラリの進化などで、クライアントサイドにおいてもより強力な表現が可能となりました。<br/>
          これを受けて、プレゼンテーション層のプログラムがサーバーサイドからクライアントサイドにシフトしていきます。従来サーバーサイドで行っていたHTMLの描画が、Web APIで必要なデータを取得すれば、クライアントサイドで可能となったためです。こちらの方が画面遷移の少なさなどによって、より優れた体験を与えられます。<br/>
        </p>

        <br/>
        <h4 class="title">Node.jsによるJavaScriptエコシステムの進化</h4>
        <p>
          2009年にはNode.jsが登場します。サーバーサイドの技術ですが、フロントエンドにも大きな2つの変化を与えます。<br/>
          1つは今までブラウザに閉じられていた実行環境が広く使えるようになったことです。Node.jsはフロントエンドの開発、検証に非常に有用な環境です。JavaScript開発の質を飛躍的に向上させました。<br/>
          もう1つはパッケージマネージャー、パッケージリポジトリであるnpmの普及です。JavaScriptで実装されたライブラリをnpm経由で利用できるようになりました。これによってモジュール（パッケージ）を適切に利用し、開発したものをモジュール化してnpm経由で配布する文化が育ちます。サーバーサイド、クライアントサイド問わずJavaScriptアプリケーションはNode.jsを利用して開発し、npmを介して提供されるようになります。<br/>
          エコシステムが整備されたとこ、他にあげている同時期のWeb全体の躍進もあり、JavaScriptライブラリは活況を迎えます。ライブラリが多種多様に出現し、開発にそれらを用いることがWebフロントエンドエンジニアに求められるようになりました。<br/>
          こういった活発なエコシステムは本来であれば歓迎すべきことです。しかしながら、初学者には変化が多い、学ぶことが多いと思われてしまう要素でもあります。<br/>
        </p>

        <br/>
        <h4 class="title">CommonJS</h4>
        <p>
          JavaScriptが抱えていた大きな問題の一つとして、て他のJSファイルを取り込む標準的な仕様が存在しなかったということが挙げられます。<br/>
          分割したファイルや、外部JSファイルを読み込みたい場合、以下のようにHTMLファイルにscriptタグを書き込むことで別ファイルを読み込んでいました。<br/>
        </p>

        <div class="codetitle">

        </div>
        <div class="code">
          &lt;script src="js/hoge_1.js"&gt;&lt;/script&gt;  //  hoge.js を分割したファイル<br/>
          &lt;script src="js/hoge_2.js"&gt;&lt;/script&gt;  //  hoge.js を分割したファイル<br/>
          &lt;script src="js/hoge_3.js"&gt;&lt;/script&gt;  //  hoge.js を分割したファイル<br/>
          &lt;script src="js/vender/fuga.js"&gt;&lt;/script&gt;<br/>
          &lt;script src="js/vender/fuga-ui.js"&gt;&lt;/script&gt; //  fuga.js を前提に作られたファイル<br/>
        </div>

        <br/>
        <p>
          このようにファイルが分割されていたり外部ファイルを読み込んでいる場合、<br/>
          単純に上から順にファイルの読み込みが行われます。<br/>

          <br/>
          問題点<br/>
          ① 変数名が被っていた場合、後から読み込んだファイルの変数名で上書きされてしまう。<br/>
          →　命名の衝突をさける為の名前空間と呼ばれる概念がない<br/>

          ② あるファイルをもとに別のファイルが作られていた場合、一方を修正するともう一方の処理が想定どおりに動かなくなってしまう。<br/>
          →　依存関係を解決する仕組みがない<br/>

          <br/>
          こういった問題を解決するためCommonJSと呼ばれるプロジェクトが発足し、様々なAPI仕様が作られて行きます。<br/>
          ①の問題については、この時に作られたモジュールAPI仕様が解決することになります。<br/>

          <br/>
          モジュールを読み込む方法（CommonJS）<br/>
          CommonJS に従って作られた新たなJavaScriptでは、 export、require 機能が使えます。<br/>
          export について、モジュール側はmodule.exportsに関数やクラスなどを定義します。<br/>

          <div class="codetitle">
            module.js
          </div>
          <div class="code">
            module.exports = function() {<br/>
            &nbsp;&nbsp;console.log('Hello World！');<br/>
            }<br/>
          </div>
        </p>

        <br/>
        <p>
          読込む側はrequire([先ほどのモジュールを定義したファイルパス])で読み込みを行います。<br/>
          <div class="codetitle">
            main.js
          </div>
          <div class="code">
            const helloWorldModule = require('./module.js');<br/>
            helloWorldModule();<br/>
            // 出力：Hello World！<br/>
          </div>

          <br/>
          モジュールを読み込む方法（ES2015）<br/>
          同じ export でも CommonJS のものとは記法が違い、モジュール側では通常通り関数やクラスを定義し、頭にexportを付けます。<br/>

          <div class="codetitle">
            module.js
          </div>
          <div class="code">
            export const helloWorld = function() {<br/>
            &nbsp;&nbsp;console.log('Hello World！');<br/>
            }<br/>
          </div>
        </p>

        <br/>
        <p>
          読み込み側ではimport文を使って先ほどのモジュールを読み込みます。<br/>
          <div class="codetitle">
            main.js
          </div>
          <div class="code">
            import { helloWorld } from './module'<br/>
            helloWorld();<br/>
            // 出力：Hello World！<br/>
          </div>
        </p>

        <br/>
        <h4 class="title">ES2015によるプログラミング言語としての進化</h4>
        <p>
          Webフロントエンド開発が高度化するなかで問題になるのがJavaScriptの言語機能の貧弱さです。<br/>
          JavaScriptは本格的なアプリケーションを作成する上ではやや物足りないところもありました。そこで大々的なアップデートが求められ、登場したのがES2015です。<br/>
          ES2015はJavaScriptの歴史上でも最大のアップデートでした。構文が増え、constやletの普及など、書き方も大々的に変わることになります。JavaScriptの仕様が増えるということは、表現力が増すと同時に覚えることも増えるということです。<br/>
          仕様が提案されてすぐ全てのブラウザに実装されるわけではありません。しかし、多くの仕様はJavaScriptへの不満を解消する魅力的なものです。そこでこういった仕様をブラウザ実装に先駆けて利用しようとする動きが広がります。<br/>
          Babelはこのニーズに応えるJavaScript to JavaScriptのコンパイラです。次世代のJavaScriptを、まだその仕様を実装していないブラウザで動作するJavaScriptに変換します。<br/>
          言語自体の複雑さもさることながら、ES2015以降の仕様の人気でコンパイラの需要が高まりビルド過程が複雑になってしまいました。<br/>
          高度な表現ができるようになることは望ましいことですが、これもやはり学習コストの増大という二面性を持ちます。<br/>
        </p>
        <p>
          2015年に標準化されたためES2015という名称になった。ES6とも呼ばれる。<br/>
          letとconst, for...of等、様々な構文が導入された。<br/>
          letとconstは変数の宣言に使用する構文で、これまで使用されてきたvarに変わるもの。
          <div class="codetitle">varによる変数の宣言</div>
            <div class="code">
              var name = 'soarflat';<br/>
              console.log(name); // => soarflat<br/>

              <br/>
              name = 'SoarFlat'; // 再代入する<br/>
              console.log(name); // => SoarFlat<br/>

              <br/>
              var name = 'SOARFLAT'; // 再宣言をする<br/>
              console.log(name); // => SOARFLAT<br/>
          </div>

          <br/>
          <div class="codetitle">letによる変数の宣言</div>
            <div class="code">
              let name = 'soarflat';<br/>
              console.log(name); // => soarflat<br/>

              <br/>
              name = 'SoarFlat'; // 再代入する<br/>
              console.log(name); // => SoarFlat<br/>

              <br/>
              let name = 'SOARFLAT'; // 再宣言するとエラーになる
          </div>

          <br/>
          <div class="codetitle">constによる変数の宣言</div>
            <div class="code">
              const NAME = 'soarflat';<br/>
              console.log(NAME); // => soarflat<br/>

              <br/>
              NAME = 'SOARFLAT'; // 再代入するとエラーになる
          </div>

          <br/>
          varは下位互換のために残しているが基本的には使用しない。<br/>

          <br/>
          Promise<br/>
          参考：<a href="https://qiita.com/soarflat/items/b251caf9cb59b72beb9b" target="_blank" rel="noopener noreferrer">Qiita ES2015(ES6) 入門</a>
        </p>

        <br/>
        <h4 class="title">Reactをはじめとするフロントエンドライブラリの出現</h4>
        <p>
          ここまで紹介してきたように、フロントエンドを取り巻く仕様、技術は高度化しています。これらが可能になったことで、アプリケーション、サービスにおいても複雑な要件が求められるようになります。<br/>
          アプリケーションデータフローをフロントエンド側で受け持つなど、設計段階から難易度が上がります。DOMをWeb APIと連動させて適切に書き換えるのも考えなしにはできません。<br/>
          こうなってくるとアプリケーションの構造化を持たないjQueryのようなライブラリでは力不足です。このため、MVCのようなアプリケーションの構造を持ったフレームワークが必要とされるようになります。Backbone.js, AngukarJAなどの新たなWebアプリケーションフレームワーク、ライブラリが次々と出現します。<br/>
          この流れで現れたのが、FacebookによるReactとFluxです。Reactはビューライブラリ、Fluxはアプリケーションアーキテクチャです。Reactを中心とした開発スタイルは仮装DOMによってDOM操作を高速で快適なものに、Fluxによって混乱しがちなフロントエンドのアークテクチャに方向性を示したことで大人気となります。<br/>
          Reactなどの登場によって、高度なフロントエンドアプリケーションの開発はjQueryで無理矢理に作るよりも構造化しやすくなりました。ここで新しく登場するのが、学習コストの問題です。<br/>
          新しいフレームワーク・ライブラリを使う以上、学習コストは発生して当然のものです。ReactもAPIを小さく保つなど学習コストをむやみに増やさない設計をしています。しかし、JSX、データフローに関する知識、ライブラリの選定とそれぞれの学習など、React導入に当たって少なくない知識が必要とされるのもまた事実です。これは各ライブラリ固有の問題ではないですが、モジュール化、ビルド、静的構文チェック、テストなどの開発環境のセットアップも確実に必要になってきます。<br/>
        </p>

        <br/>
        <h4 class="title">AltJSの登場</h4>
        <p>
          ES2015と前後して登場したのがJavaScriptに変換できる、AltJSと呼ばれるプログラミング言語です。より簡潔な構文を目指したCofeeScript、型を注釈として付与するTypeScriptが有名です。<br/>
          特にTypeScriptは現在の開発で広く使われるようになりつつあります。<br/>
        </p>

        <br/>
        <h3 class="title">現在の課題とVue.js</h3>
        <p>
          現在のフロントエンド開発は次のような進化、課題を抱えながら現在に至っています。相互に影響しあっている部分もあります。これらはアプリケーションとして高度になる上では避けられないところでもあります。<br/>
        </p>

        <ul>
          <li>HTML5以降のアプリケーションプラットフォームとしてのリッチ化と、それに伴うAPIの高度化</li>
          <li>Node.jsエコシステムの発展と、開発環境構築の難化</li>
          <li>ES2015以降のシンタックスの強化と、覚えることの多さ</li>
          <li>React以降のフロントエンド開発のフレームワーク化と、フレームワークにまつわる学習コスト</li>
        </ul>

        <br/>
        <h3 class="title">フロントエンドの課題の変遷</h3>
        <table border="1">
          <tr><th>時期</th><th>フロントエンドの役割</th><th>サーバーの役割</th><th>JavaScriptライブラリ・フレームワーク</th></tr>
          <tr><td>Webシステム初期</td><td>装飾</td><td>HTMLの生成</td><td>なし</td></tr>
          <tr><td>Ajax期</td><td>Ajaxを中心としたインタラクション</td><td>HTMLの生成＋API</td><td>jQueryやprototype.js</td></tr>
          <tr><td>現在</td><td>アプリケーションのプレゼンテーション全般</td><td>API</td><td>Vue.jsやReact, Angular</td></tr>
        </table>

        <br/>
        <h3 class="title">関連技術</h3>
        <ul>
          <li>【工事中】jQuery</li>
          <li><a href="nodejs.html">nodejs</a></li>
          <li><a href="typescript.html">TypeScript(AltJS)</a></li>
          <li><a href="spa/spa.html">SPA(Single Page Application)</a></li>
        </ul>

        <br/>
        参考<br/>
        <ul>
          <li><a href="https://thinkit.co.jp/article/10644" target="_blank" rel="noopener noreferrer">ThinkIT ES2015のモジュール管理</a></li>
          <li><a href="https://maru-note.net/entry/2023/01/28/185158" target="_blank" rel="noopener noreferrer">まるノート JavaScriptの歴史 ～CommonJSとES2015～</a></li>
          <li><a href="https://ics.media/entry/16511/" target="_blank" rel="noopener noreferrer">ICS MEDIA ES Modules入門 JavaScriptでモジュールを使う時代</a></li>
          <li><a href="https://zenn.dev/yodaka/articles/596f441acf1cf3" target="_blank" rel="noopener noreferrer">Zenn CommonJSとES Modulesについてまとめる</a></li>
        </ul>
      </section><!-- section class="box" -->

      <footer>
        <small><a href="https://taumax-github.github.io/">とあるＩＴエンジニアの知識整理</a> All Rights Reserved.</small>
        <span class="pr"><a href="https://template-party.com/" target="_blank">《Web Design:Template-Party》</a></span>
      </footer>

    </div><!--/#main-->
    </div><!--/#contents-->
    </div><!--/#container-->
  </body>

  <!--ページの上部に戻る「↑」ボタン-->
  <p class="nav-fix-pos-pagetop"><a href="#pagetop">↑</a></p>

  <!--メニュー開閉ボタン-->
  <div id="menubar_hdr" class="close"></div>
    <!--メニューの開閉処理条件設定　800px以下-->
    <script>
      if (OCwindowWidth() <= 800) {
        open_close("menubar_hdr", "menubar-s");
      }
    </script>
</html>
